int mkdir(const char *pathname, mode_t mode);
- mkdir създава директория с име pathname и права на достъп mode. Новосъздадената директория е собственост на процеса, който я е създал. Празната директория съдържа само "." - за самата директория и ".." - за родителската директория.

int rmdir(const char *pathname);
 - Изтрива директория с дадено име, само ако тя е празна.

 int chdir(const char *path);
 - Сменя директориятавърху, която работи извикващия процес с друга, чието име е указано като аргумент.

 DIR *opendir(const char *name);
 - Отваря канал за работа с дадена директория, като връща указател към структурата й. Първоначално указателят е позициониран към началото на директорията. При грешка връща NULL.

 struct dirent *readdir(DIR *dirp);
 - Чете поредния запис в директорията(като те не са подредени по азбучен ред). Аргументът е указател към самата директория, от която четем, а като резултат връща структурата на следващи запис в директорията.

int closedir(DIR *dirp);
- Затваря комуникационния канал към директорията посочена под формата на указател като аргумент. При успех затваря и файловия дескриптор, който сочи към тази директория.При успех връща 0, а при грешка - -1.

void rewinddir(DIR *dirp);
- Връща указателя, който сочи към съдържанието на директорията в неговото начало. Все едно да използваме lseek(fd, 0, SEEK_SET) при файлове.


Shared memory API позволява процесите да комуникират помежду си като споделят обща област от паметта.

int shm_open(const char *name, int oflag, mode_t mode);
- Връща дескриптор към конкретна споделена памет. За разлика при файловете тук не можем да ползваме write() or read(), а само указваме на извикващия процес с коя сподлена памет ще работи. Имената на споделените памети започват с / и след това нямат повече слашове, защото по default споделените памети се съхраняват в /dev/shm. Флагове могат да бъдат O_RDONLY, O_RDWR, O_CREAT, O_TRUNC, etc. като са еквивалентни на тези при файловете.

Когато създаваме нова памет, тя има дължина 0.
Затова използваме int ftruncate(int fd, off_t length), с което указваме дължината й.

int shm_unlink(const char *name);
- Изтрива споделената памет. При успех връща 0.

fstat() връща структура, която описва споделента памет(т.е. дава ни нещо като мета информация за нея).

int fchown(int fd, uid_t owner, gid_t group);
- Променя собственика на споделената памет с дескриптор fd.

int fchmod(int fd, mode_t mode);
- Променя правата за достъп до споделената памет.

И сега черешката на тортата :D
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
- Създава ново адресиране във виртуалното адресно пространство на извикваши процес. Началният адрес се указва чрез addr, a length е дължината на този mapping. Препоръчва се addr да e NULL, като по този начин ядрото преценя само откъде да започне адресирането. Аргументът prot представлява аргументи за зашита. Те могат да бъдат
  PROT_EXEC - Pages may be executed.
  PROT_READ - Pages may be read.
  PROT_WRITE - Pages may be write.
  PROT_NONE - Pages may not be accessed.
fd указва откъде ще вземаме данните, които ще съхраняваме в съответното адресно пространство.
offset - от каква позиция нататък ще извличаме данните от споделената памет.

int munmap(void *addr, size_t length);
- Освобождава обектът на споделената памет от виртуалното адресно пространсто на извикващи процес. И при бъдещи опити да достъпим този адрес, който сме освободили току що, ще получим съобщение за грешка. От друга страна, ако затворим файловия дескриптор сочещ съм споделената памет, ние не го изтриваме от виртуалното адресно пространство.

В основата си семафорът е брояч. Ако той стане негативен, ще приспи даден процес, а когато е отново неотрицателен - ще го събуди. Семафорите могат да бъдат именувани и неименувани. Неименуваните семафори са разположени в споделената памет.

sem_t *sem_open(const char *name, int oflag);
- Връща указател към структурата на семафора.

int sem_close(sem_t *sem);
- Затваря даден семафор.

Семафор се унищожава със sem_unlink(sem_t *sem);

Когато създадем семафор, ние трябва да го инициализираме с начална стойност. Това става чрез:
int sem_init(sem_t *sem, int pshared, unsigned int value);
- value е началната стойност, а с pshared указваме дали семафорът ще бъде споделен между нишките на извикващия процес(=0) или между няколко процеса(!=0).

int sem_destroy(sem_t *sem);
- Служи като деструктор на неименуван семафор. Ако се унищожи семафор, който е приспал процеси ще се наблюдават нежелани ефекти.

int sem_post(sem_t *sem);
- Увеличава брояча да семафора с единица.

int sem_wait(sem_t *sem);
- Намалява брояча на семафора с единица. Ако е по-голям от 0, не се случва нищо. Ако е бил 0, се блокира процеса, докато отново не стане брояча неотрицателен.

int sem_trywait(sem_t *sem);
- Върши същата работа като sem_wait, но ако опитаме да приспим процес, който е важен за нас, той няма да бъде приспан.

int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
- Указва след колко наносекунди да бъде блокиран извикващия процес.


Съобщенията представляват нещо като пощенска кутия, където се събират писма в опашка. По този начин се обменят данни между процесите. Кутиите са с фиксиран размер и процесът изпращач бива приспан, докато получателят не си вземе съобщението и обратно.

mqd_t mq_open(const char *name, int oflag);
- Създава нова или отваря съществуваща опашка за съобщения, която е именувана с name. oflag са битове, с което се указва начина, по който ще бъде използвана опашката. При успех връща дескриптора на опашката за съобщения, а при грешка - -1.

int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio);
- Добавя съобщението msg_ptr към опашка с дескриптор mqdes. msg_prio представлява неотрицателно число, което задава приоритет на съобщението. Съобщенията в опашката са подредени от най-приоритетни към по-неприоритетни. Тези, които са с еднакъв приоритет се подреждат според реда, в който са добавени. Ако опашката вече е запълнена изпращането на съобщението блокира, докато не се освободи място в кутията. Ако пък при отварянето на опашката сме задали флаг O_NONBLOCK и тя е запълнена, изпращането на съобщение до нея директно спира с код за грешка, вместо да блокира.

ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio);
- Премахва най-старото съобщение с най-висок приоритет от опашката и го поставя в буфера msg_ptr с дължина msg_len. Ако msg_prio не е NULL, то буферът се използва за да върне информация относно приоритетността на това съобщение.

